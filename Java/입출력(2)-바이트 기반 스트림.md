# 입출력 I/O(2) - 바이트 기반 스트림

Created: Nov 10, 2019 9:58 PM

## InputSteam과 OutputStream

InputStream과 OutputStream은 모든 바이트기반 스트림의 조상이다. 스트림의 종류에 따라서 mark()와 reset()를 사용하여 이미 읽은 데이터를 되돌려서 다시 읽을 수 있다. 이 기능을 지원하는 스트림인지는 markSupported()를 통해서 알 수 있다. flush()는 버퍼가 있는 출력스트림의 경우에만 의미가 있으며, OutputStream에 정의된 flush()는 아무런 일도 하지 않는다. 프로그램이 종료될 때, 사용하고 닫지 않은 스트림을 JVM이 자동적으로 닫아 주기는 하지만, 스트림을 사용해서 모든 작업을 마치고 난 후에는 close()를 호출해서 반드시 닫아주어야 한다. 그러나 ByteArrayInputStream과 같이 메모리를 사용하는 스트림과 System.in, System.out과 같은 표준 입출력 스트림은 닫아 주지 않아도 된다.

## ByteArrayInputStream과 ByteArrayOutputStream

메모리, 즉 바이트배열에 데이터를 입출력 하는데 사용되는 스트림이다. 주로 다른 곳에 입출력하기 전에 데이터를 임시로 바이트배열에 담아서 변환 등의 작업을 하는데 사용된다.

    class IOEx1 {
    	public static void main(String[] args){
    		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
    		byte[] outSrc = null;
    
    		ByteArrayInputStream input = null;
    		ByteArrayOutputStream output = null;
    
    		input = new ByteArrayInputStream(inSrc);
    		output = new ByteArrayOutputStream();
    
    		int data = 0;
    		
    		while((data = input.read()) != -1){
    			output.write(data);
    		}
    
    		outSrc = output.toByteArray();
    
    		System.out.println("Input Source :" + Arrays.toString(inSrc));
    		System.out.println("Output Source :" + Arrays.toString(outSrc));
    	}
    }
    
    // Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

바이트배열은 사용하는 자원이 메모리 밖에 없으므로 GC에 의해 자동적으로 자원을 반환한다. 따라서 close()를 이용해서 스트림을 닫지 않아도 된다. read()와 write(int b)를 사용하기 때문에 한 번에 1 byte만 읽고 쓰므로 작업효율이 떨어진다.

    class IOEx2 {
    	public static void main(String[] args){
    		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
    		byte[] outSrc = null;
    		byte[] temp = new byte[10];
    
    		ByteArrayInputStream input = null;
    		ByteArrayOutputStream output = null;
    
    		input = new ByteArrayInputStream(inSrc);
    		output = new ByteArrayOutputStream();
    
    		input.read(temp, 0, temp.length) // 읽어 온 데이터를 배열 temp에 담는다.
    		output.write(temp, 5, 5); // temp[5]부터 5개의 데이터를 write한다.
    
    		outSrc = output.toByteArray();
    
    		System.out.println("Input Source :" + Arrays.toString(inSrc));
    		System.out.println("temp :" + Arrays.toString(temp));
    		System.out.println("Output Source :" + Arrays.toString(outSrc));
    	}
    }
    
    // Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // temp :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // Output Source :[5, 6, 7, 8, 9]

배열을 이용한 입출력은 작업의 효율을 증가시키므로 가능하면 입출력 대상에 따라 알맞은 크기의 배열을 사용하는 것이 좋다.

    class IOEx3 {
    	public static void main(String[] args){
    		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
    		byte[] outSrc = null;
    		byte[] temp = new byte[4];
    
    		ByteArrayInputStream input = null;
    		ByteArrayOutputStream output = null;
    
    		input = new ByteArrayInputStream(inSrc);
    		output = new ByteArrayOutputStream();
    
    		try {
    			while(input.available() > 0){
    				int len = input.read(temp); // 읽어 온 데이터의 개수를 반환
    				output.write(temp, 0, len); // 읽어 온 만큼만 write
    			}
    		} catch(IOException e) {}
    
    		outSrc = output.toByteArray();
    
    		System.out.println("Input Source :" + Arrays.toString(inSrc));
    		System.out.println("temp :" + Arrays.toString(temp));
    		System.out.println("Output Source :" + Arrays.toString(outSrc));
    	}
    }
    
    // Input Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // temp :[8, 9, 6, 7]
    // Output Source :[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

read()나 write()가 IOException을 발생시킬 수 있기 때문에 try-catch문으로 감싸주었다. available()은 blocking 없이 읽어 올 수 있는 바이트의 수를 반환한다.

## FIleInputStream과 FileOutputStream

파일에 입출력을 하기 위한 스트림이다. 실제 프로그래밍에서 많이 사용되는 스트림 중 하나이다.

FileInputStream(String name), 지정된 파일이름(name)을 가진 실제 파일과 연결된 FIleInputStream을 생성

FileInputStream(File file), 파일의 이름이 String이 아닌 File 인스턴스로 지정해주어야 하는 점을 제외하고 FileInputStream(String name)과 같다.

FileInputStream(FileDescriptor fdObj), 파일 디스크립터(fdObj)로 FileInputStream을 생성

FileOutputStream(String name), 지정된 파일이름을 가진 실제 파일과 연결된 FIleOutputStream을 생성

FileOutputStream(String name, boolean append), 지정된 파일이름을 가진 실제 파일과 연결된 FileOutputStream을 생성한다. 두번째 인자인 append를 true로 하면, 출력 시 기존의 파일내용의 마지막에 덧붙인다. false면 기존의 파일내용을 덮어쓰게 된다.

FileOutputStream(File file)

FileOutputStream(File file, boolean append)

FileOutputStream(FileDescriptor fdObj)

    class FileViewer {
    	public static void main(String args[]) throws IOException{
    		FileInputStream fis = new FileInputStream(args[0]);
    		int data = 0;
    		
    		while((data = fis.read()) != -1){
    			char c = (char)data;
    			System.out.print(c);
    		}
    	}
    }
    
    // >java FileViewer FileViewer.java

커맨드라인으로부터 입력받은 파일의 내용을 읽어서 그대로 화면에 출력하는 간단한 예제이다. read()의 반환값이 int(4 byte)이긴 하지만, 더 이상 입력값이 없음을 알리는 -1을 제외하고는 0~255(1 byte) 범위의 정수값이기 때문에, char형(2 byte)으로 변환한다 해도 손실되는 값은 없다.

read()가 한 번에 1 byte씩 파일로부터 데이터를 읽어 들이긴 하지만, 데이터의 범위가 십진수로 0~255(16진수로는 0x00~0xff)범위의 정수값이고, 또 읽을 수 있는 입력값이 더 이상 알릴 수 있는 값(-1)도 필요하다. 그래서 다로 크긴 하지만 정수형 중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한 것이다.

    class FileCopy{
    	public static void main(String args[]){
    		try {
    			FileInputStream fis = new FileInputStream(args[0]);
    			FileOutputStream fos = new FileOutputStream(args[1]);
    
    			int data = 0;
    			while((data = fis.read()) != -1) {
    				fos.write(data);
    			}
    
    			fis.close();
    			fos.close();
    		} catch(IOException e){
    			e.printStackTrace();
    		}
    	}
    }
    
    // >java FileCopy FileCopy.java FileCopy.bak

텍스트파일을 다루는 경우에는 FileInputStream/FileOutputStream 보다 문자기반의 스트림인 FileReader/FileWriter를 사용하는 것이 더 좋다.